<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/hyde/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/hyde/" rel="alternate" type="text/html" /><updated>2020-04-01T09:50:09-07:00</updated><id>http://localhost:4000/hyde/feed.xml</id><title type="html">Peter Rindal</title><subtitle></subtitle><author><name>Peter Rindal</name></author><entry><title type="html">result&amp;lt; T, E &amp;gt;: Seamless error_code’s with C++ Coroutines</title><link href="http://localhost:4000/hyde/blog/2020/03/31/result.html" rel="alternate" type="text/html" title="result&lt; T, E &gt;: Seamless error_code's with C++ Coroutines" /><published>2020-03-31T00:00:00-07:00</published><updated>2020-03-31T00:00:00-07:00</updated><id>http://localhost:4000/hyde/blog/2020/03/31/result</id><content type="html" xml:base="http://localhost:4000/hyde/blog/2020/03/31/result.html">&lt;h3 id=&quot;the-idea&quot;&gt;The Idea&lt;/h3&gt;

&lt;p&gt;The other day I was reviewing some code when I saw the use of a macro to simplify handling an &lt;code class=&quot;highlighter-rouge&quot;&gt;error_code&lt;/code&gt; like type. I’m sure most of us have seen code like this&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Either return the error or assign &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the value type of rexpr to lhs.&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define ASSIGN_OR_RETURN(lhs, rexpr) ...
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ASSIGN_OR_RETURN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this example &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;&lt;/code&gt; is a discriminated union / sum type, it will either hold the expected type &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, or in can of an error it will hold an &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;. The macro &lt;code class=&quot;highlighter-rouge&quot;&gt;ASSIGN_OR_RETURN&lt;/code&gt; returns the error type if the error type is active and otherwise assigns the value type to &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I think its pretty obvious why the use of the macro is less than desirable.
 &lt;!--more--&gt;
Apprently the author of the code had picked this pattern up at google where &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T, error_code&amp;gt; = StatusOr&amp;lt;T&amp;gt;&lt;/code&gt;.  While chatting they mentioned how they wish C++ had the &lt;a href=&quot;https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html&quot;&gt;Rust&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;operator ?&lt;/code&gt; which effectively does the same thing as the macro.&lt;/p&gt;

&lt;p&gt;But this got me thinking… Shortly before I was playing around with the new C++ coroutine TS (very excited ;). From my understanding, the coroutine keyword &lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt; effectively allows us to shim in arbitrary code at the site of the  &lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt; operator. In particular, this mechanism can allow us to return early from the function. I was invisioning something like the following:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While I am not the first to have this basic observation, e.g. &lt;a href=&quot;https://github.com/facebook/folly/blob/72c71129647d3f12402364e818336125d911fa8d/folly/Expected.h&quot;&gt;folly::expected&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/a68wjo/investigating_what_is_really_needed_to_have/&quot;&gt;this reddit post&lt;/a&gt;, I beleive this capability deserves more attention and is a good example to learn from. Moreover, while exploring this idea I quickly discovered that this code be further simplified to just&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;All three of these example have the same exact behavior. If &lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt; returns an &lt;code class=&quot;highlighter-rouge&quot;&gt;error_code&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;bar()&lt;/code&gt; will propegate this same &lt;code class=&quot;highlighter-rouge&quot;&gt;error_code&lt;/code&gt; threw the return channel.&lt;/p&gt;

&lt;p&gt;To my suprise this solution can also provides guarantted exception safety. Consider the following,&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;At first glance the &lt;code class=&quot;highlighter-rouge&quot;&gt;noexcept&lt;/code&gt; seems incorrect. However, it is possible to configure the &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;&lt;/code&gt; type so that it can capture all exceptions and record them as the error type, in the case &lt;code class=&quot;highlighter-rouge&quot;&gt;error_core&lt;/code&gt;. In the implementation I also show how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::exception_ptr&lt;/code&gt; as the error type to allow us to keep the runtime information contained in the current exception.&lt;/p&gt;

&lt;h3 id=&quot;the-resultte-type&quot;&gt;The result&amp;lt;T,E&amp;gt; type&lt;/h3&gt;

&lt;p&gt;The code I will be discussing can be found &lt;a href=&quot;https://github.com/ladnir/result&quot;&gt;here&lt;/a&gt; but be warned it is just a prototype. For production level code that does some of that I have described see &lt;a href=&quot;https://github.com/facebook/folly/blob/72c71129647d3f12402364e818336125d911fa8d/folly/Expected.h&quot;&gt;folly::expected&lt;/a&gt;. My &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;&lt;/code&gt; has the follwoing form&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;result&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exception_handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// constructors...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// accessing members &lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has_error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;error_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;awaiter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;promise_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For now we can ignore the &lt;code class=&quot;highlighter-rouge&quot;&gt;exception_handler&lt;/code&gt;. The critical type for our concerns is the &lt;code class=&quot;highlighter-rouge&quot;&gt;promise_type&lt;/code&gt; type. When the compiler sees the one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;co_*&lt;/code&gt; keywords in a function body the compiler will look up the &lt;code class=&quot;highlighter-rouge&quot;&gt;promise_type&lt;/code&gt; of the current return type, in our case &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;::promise_type&lt;/code&gt;. The compiler will then roughtly transform the function&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;into&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;promise_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;promise_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;promise_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_return_object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  
  &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;awaiter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;promise_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await_transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await_suspend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await_resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As the implementer of &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;&lt;/code&gt;, we have control over the body of these inserted functions. It is then a relatively simple matter to acheive the desired logic. First, we will have &lt;code class=&quot;highlighter-rouge&quot;&gt;promise_type::get_return_object() -&amp;gt; promise_type&amp;amp;&lt;/code&gt; return a reference to itself and give &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;&lt;/code&gt; the following constructor&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;promise_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;    

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proise_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;promise_type&lt;/code&gt; will then hold the pointer to the &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; as a member. The &lt;code class=&quot;highlighter-rouge&quot;&gt;awaiter&lt;/code&gt; type &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; will then similarly hold a pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;b_ptr&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; which is provided via the &lt;code class=&quot;highlighter-rouge&quot;&gt;await_transform(b)&lt;/code&gt; function. During the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;a.await_ready()&lt;/code&gt;, the implementation will check if &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; contains an &lt;code class=&quot;highlighter-rouge&quot;&gt;error_type&lt;/code&gt; and if so return &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;. The subsequant call to &lt;code class=&quot;highlighter-rouge&quot;&gt;a.await_suspend(prom)&lt;/code&gt; can then set &lt;code class=&quot;highlighter-rouge&quot;&gt;*prom.result_ptr = a.b_ptr-&amp;gt;error()&lt;/code&gt;. Alternative, if &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; does not contain an error then &lt;code class=&quot;highlighter-rouge&quot;&gt;a.await_resume()&lt;/code&gt; can similarly return the underlying &lt;code class=&quot;highlighter-rouge&quot;&gt;value_type&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While this gives us a solid solution, we still must use the &lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt; keywork to generate this transformation. If you recall eariler, we desired to write&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For this we will add an implicit converstion operator &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;::operator T()&lt;/code&gt; which throws an &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; in the event that the error type is active. This convertion operator will then implicicitly be called for &lt;code class=&quot;highlighter-rouge&quot;&gt;int i = bar();&lt;/code&gt;. In the event that an &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; is throw we can imidiately catch it using the following&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;promise_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unhandled_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;  

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proise_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The way this all works is as follows. When an exception is thrown in a coroutine it is automaticly caught and within the &lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt; block the function&lt;code class=&quot;highlighter-rouge&quot;&gt;promise_type::unhandled_exception()&lt;/code&gt; is called. The current exception can then be rethrow using &lt;code class=&quot;highlighter-rouge&quot;&gt;throw;&lt;/code&gt; which in turn allows us to catch the underlying &lt;code class=&quot;highlighter-rouge&quot;&gt;error_type&lt;/code&gt; and store it in the return &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T,E&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The final missing piece is how to handle arbitrary exceptions. For this the library provides a way for the user to customize how an exception is converted into an error type. This is achieved by providing the third template parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;exception_handler&lt;/code&gt; with two member functions that contain the desired logic. When working with error codes one option is to simply throw out all the runtime information associated with the exception and store a generic error code indicating that an exception was caught and supressed. This option can be found &lt;a href=&quot;https://github.com/ladnir/result/blob/master/result/result.h#L341&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Alternatively, it is possible to instantiate an &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; type with &lt;code class=&quot;highlighter-rouge&quot;&gt;result&amp;lt;T, std::exception_ptr&amp;gt;&lt;/code&gt; where no runtime exception information is thrown away. It is then possible to specify an &lt;code class=&quot;highlighter-rouge&quot;&gt;exception_handler&lt;/code&gt; which catches all exceptions and stores them as an &lt;code class=&quot;highlighter-rouge&quot;&gt;std::exception_ptr&lt;/code&gt;, if the user does an unchecked access to the &lt;code class=&quot;highlighter-rouge&quot;&gt;value_type&lt;/code&gt;, the captured &lt;code class=&quot;highlighter-rouge&quot;&gt;std::exception_ptr&lt;/code&gt; can be rethrown using &lt;code class=&quot;highlighter-rouge&quot;&gt;std::rethrow_exception(...)&lt;/code&gt;. This option can be found &lt;a href=&quot;https://github.com/ladnir/result/blob/master/result/result.h#L360&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a final remark I’d like to say that this is just an example of what could be done. It is far from clear that everything I stated here is actually the best design choice. Certainly the ideas about how to remove the the use of the &lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt; keyword by throwing an exception is likely not the most efficient, although it is hard to say what the compiler will optimize away.&lt;/p&gt;

&lt;p&gt;Cheers,
Peter&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="cpp" /><category term="coroutine" /><summary type="html">The Idea The other day I was reviewing some code when I saw the use of a macro to simplify handling an error_code like type. I’m sure most of us have seen code like this // Either return the error or assign // the value type of rexpr to lhs. #define ASSIGN_OR_RETURN(lhs, rexpr) ... result&amp;lt;int, error_code&amp;gt; foo() { ... } result&amp;lt;bool, error_code&amp;gt; bar() { ASSIGN_OR_RETURN(int i, bar()); return i == 3; } In this example result&amp;lt;T,E&amp;gt; is a discriminated union / sum type, it will either hold the expected type T, or in can of an error it will hold an E. The macro ASSIGN_OR_RETURN returns the error type if the error type is active and otherwise assigns the value type to i. I think its pretty obvious why the use of the macro is less than desirable.</summary></entry><entry><title type="html">Fast Database Joins for Secret Shared Data</title><link href="http://localhost:4000/hyde/publications/2019/04/27/db-join.html" rel="alternate" type="text/html" title="Fast Database Joins for Secret Shared Data" /><published>2019-04-27T00:00:00-07:00</published><updated>2019-04-27T00:00:00-07:00</updated><id>http://localhost:4000/hyde/publications/2019/04/27/db-join</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2019/04/27/db-join.html">&lt;p&gt;Payman Mohassel, Peter Rindal &amp;amp; Mike Rosulek ~ &lt;a href=&quot;https://eprint.iacr.org/2019/518&quot;&gt;eprint/2019/518&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We present a scalable database join protocol for secret shared data in the honest majority three party setting. The key features of our protocol are a rich set of SQL-like join/select queries and the ability to compose join operations together due to the inputs and outputs being generically secret shared between the parties. Given that the keys being joined on are unique, no information is revealed to any party during the protocol. In particular, not even the sizes of intermediate joins are revealed. All of our protocols are constant-round and achieve O(n) communication and computation overhead for joining two tables of n&lt;/p&gt;

&lt;p&gt;rows.&lt;/p&gt;

&lt;p&gt;In addition to performing database joins our protocol, we implement two applications on top of our framework. The first performs joins between different governmental agencies to identify voter registration errors in a privacy-preserving manner. The second application considers the scenario where several organizations wish to compare network security logs to more accurately identify common security threats, e.g. the IP addresses of a bot net. In both, cases the practicality of these applications depends on efficiently performing joins on millions of secret shared records. For example, our three party protocol can perform a join on two sets of 1 million records in 4.9 seconds or, alternatively, compute the cardinality of this join in just 3.1 seconds.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="MPC" /><category term="Semi-honest" /><category term="Honest Majority" /><category term="Secret Sharing" /><category term="Private Set Intersection" /><category term="Secure Join" /><category term="Payman Mohassel" /><category term="Mike Rosulek" /><summary type="html">Payman Mohassel, Peter Rindal &amp;amp; Mike Rosulek ~ eprint/2019/518 We present a scalable database join protocol for secret shared data in the honest majority three party setting. The key features of our protocol are a rich set of SQL-like join/select queries and the ability to compose join operations together due to the inputs and outputs being generically secret shared between the parties. Given that the keys being joined on are unique, no information is revealed to any party during the protocol. In particular, not even the sizes of intermediate joins are revealed. All of our protocols are constant-round and achieve O(n) communication and computation overhead for joining two tables of n rows. In addition to performing database joins our protocol, we implement two applications on top of our framework. The first performs joins between different governmental agencies to identify voter registration errors in a privacy-preserving manner. The second application considers the scenario where several organizations wish to compare network security logs to more accurately identify common security threats, e.g. the IP addresses of a bot net. In both, cases the practicality of these applications depends on efficiently performing joins on millions of secret shared records. For example, our three party protocol can perform a join on two sets of 1 million records in 4.9 seconds or, alternatively, compute the cardinality of this join in just 3.1 seconds.</summary></entry><entry><title type="html">Cheaper Private Set Intersection via Differentially Private Leakage</title><link href="http://localhost:4000/hyde/publications/2019/02/27/cheaper-psi.html" rel="alternate" type="text/html" title="Cheaper Private Set Intersection via Differentially Private Leakage" /><published>2019-02-27T00:00:00-08:00</published><updated>2019-02-27T00:00:00-08:00</updated><id>http://localhost:4000/hyde/publications/2019/02/27/cheaper-psi</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2019/02/27/cheaper-psi.html">&lt;p&gt;Adam Groce, Peter Rindal &amp;amp; Mike Rosulek ~ &lt;a href=&quot;https://eprint.iacr.org/2019/1159&quot;&gt;eprint/2019/1159&lt;/a&gt; ~ &lt;a href=&quot;https://petsymposium.org/cfp19.php&quot;&gt;PETS’19&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this work we demonstrate that allowing differentially private leakage can significantly improve the concrete performance of secure 2-party computation (2PC) protocols. Specifically, we focus on the private set intersection (PSI) protocol of Rindal and Rosulek (CCS 2017), which is the fastest PSI protocol with security against malicious participants. We show that if differentially private leakage is allowed, the cost of the protocol can be reduced by up to 63%, depending on the desired level of differential privacy. On the technical side, we introduce a security model for differentially-private leakage in malicious-secure 2PC. We also introduce two new and improved mechanisms for “differentially private histogram overestimates,” the main technical challenge for differentially-private PSI.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="2PC" /><category term="Oblivious Transfer" /><category term="Private Set Intersection" /><category term="Differential Privacy" /><category term="Malicious" /><category term="Adam Groce" /><category term="Mike Rosulek" /><category term="PETS" /><summary type="html">Adam Groce, Peter Rindal &amp;amp; Mike Rosulek ~ eprint/2019/1159 ~ PETS’19 In this work we demonstrate that allowing differentially private leakage can significantly improve the concrete performance of secure 2-party computation (2PC) protocols. Specifically, we focus on the private set intersection (PSI) protocol of Rindal and Rosulek (CCS 2017), which is the fastest PSI protocol with security against malicious participants. We show that if differentially private leakage is allowed, the cost of the protocol can be reduced by up to 63%, depending on the desired level of differential privacy. On the technical side, we introduce a security model for differentially-private leakage in malicious-secure 2PC. We also introduce two new and improved mechanisms for “differentially private histogram overestimates,” the main technical challenge for differentially-private PSI.</summary></entry><entry><title type="html">Endemic Oblivious Transfer</title><link href="http://localhost:4000/hyde/publications/2019/02/27/endemic-ot.html" rel="alternate" type="text/html" title="Endemic Oblivious Transfer" /><published>2019-02-27T00:00:00-08:00</published><updated>2019-02-27T00:00:00-08:00</updated><id>http://localhost:4000/hyde/publications/2019/02/27/endemic-ot</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2019/02/27/endemic-ot.html">&lt;p&gt;Daniel Masny &amp;amp; Peter Rindal ~ &lt;a href=&quot;https://eprint.iacr.org/2019/706&quot;&gt;eprint/2019/706&lt;/a&gt; ~ &lt;a href=&quot;https://www.sigsac.org/ccs/CCS2019/&quot;&gt;CCS’19&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Oblivious Transfer has played a crucial role in the design of secure multi party computation. Nevertheless, there are not many practical solutions that achieve simulation based security and at the same time instantiable based on different assumptions.&lt;/p&gt;

&lt;p&gt;In this work, we consider a simulation based security notion that we call endemic security. We show how to construct highly efficient oblivious transfer in the random oracle model that achieves endemic security under a wide range of assumptions, among them DDH, CDH, LWE and coding based assumptions. We construct a secure oblivious transfer based on DDH that takes only a single communication round which allows significant performance gains. We also instantiate our oblivious transfer with the Crystals.Kyber key agreement. Our implementation shows that both instantiations can be computed in under one millisecond.&lt;/p&gt;

&lt;p&gt;Further, we revisit, correct and improve existing oblivious transfer extension techniques. We provide an implementation of an oblivious transfer extension protocol in the ideal cipher model that is actively secure, processing up to 23 million OTs per second and up to 10 times faster than previous secure implementations. We also show that our framework can compute endemically secure OT extension and the base OTs in just two rounds.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="2PC" /><category term="Malicious" /><category term="Post Quantum" /><category term="Oblivious Transfer" /><category term="Malicious" /><category term="Daniel Masny" /><category term="CCS" /><summary type="html">Daniel Masny &amp;amp; Peter Rindal ~ eprint/2019/706 ~ CCS’19 Oblivious Transfer has played a crucial role in the design of secure multi party computation. Nevertheless, there are not many practical solutions that achieve simulation based security and at the same time instantiable based on different assumptions. In this work, we consider a simulation based security notion that we call endemic security. We show how to construct highly efficient oblivious transfer in the random oracle model that achieves endemic security under a wide range of assumptions, among them DDH, CDH, LWE and coding based assumptions. We construct a secure oblivious transfer based on DDH that takes only a single communication round which allows significant performance gains. We also instantiate our oblivious transfer with the Crystals.Kyber key agreement. Our implementation shows that both instantiations can be computed in under one millisecond. Further, we revisit, correct and improve existing oblivious transfer extension techniques. We provide an implementation of an oblivious transfer extension protocol in the ideal cipher model that is actively secure, processing up to 23 million OTs per second and up to 10 times faster than previous secure implementations. We also show that our framework can compute endemically secure OT extension and the base OTs in just two rounds.</summary></entry><entry><title type="html">Efficient Two-Round OT Extension and Silent Non-Interactive Secure Computation</title><link href="http://localhost:4000/hyde/publications/2019/02/27/silent-ot.html" rel="alternate" type="text/html" title="Efficient Two-Round OT Extension and Silent Non-Interactive Secure Computation" /><published>2019-02-27T00:00:00-08:00</published><updated>2019-02-27T00:00:00-08:00</updated><id>http://localhost:4000/hyde/publications/2019/02/27/silent-ot</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2019/02/27/silent-ot.html">&lt;p&gt;Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Peter Rindal, Peter Scholl ~ &lt;a href=&quot;https://eprint.iacr.org/2019/706&quot;&gt;eprint/2019/706&lt;/a&gt; ~ &lt;a href=&quot;https://www.sigsac.org/ccs/CCS2019/&quot;&gt;CCS’19&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We consider the problem of securely generating useful instances of two-party correlations, such as many independent copies of a random oblivious transfer (OT) correlation, using a small amount of communication. This problem is motivated by the goal of secure computation with silent preprocessing, where a low-communication input-independent setup, followed by local (“silent”) computation, enables a lightweight “non-cryptographic” online phase once the inputs are known.&lt;/p&gt;

&lt;p&gt;Recent works of Boyle et al. (CCS 2018, Crypto 2019) achieve this goal with good concrete efficiency for useful kinds of two-party correlations, including OT correlations, under different variants of the Learning Parity with Noise (LPN) assumption, and using a small number of “base” oblivious transfers. The protocols of Boyle et al. have several limitations. First, they require a large number of communication rounds. Second, they are only secure against semi-honest parties. Finally, their concrete efficiency estimates are not backed by an actual implementation. In this work we address these limitations, making three main contributions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Eliminating interaction. Under the same assumption, we obtain the first concretely efficient 2-round protocols for generating useful correlations, including OT correlations, in the semi-honest security model. This implies the first efficient 2-round OT extension protocol of any kind and, more generally, protocols for non-interactive secure computation (NISC) that are concretely efficient and have the silent preprocessing feature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Malicious security. We provide security against malicious parties (in the random oracle model) without additional interaction and with only a modest concrete overhead; prior to our work, no similar protocols were known with any number of rounds.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Implementation. Finally, we implemented, optimized, and benchmarked our 2-round OT extension protocol, demonstrating that it offers a more attractive alternative to the OT extension protocol of Ishai et al. (Crypto 2003) in many realistic settings.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Peter Rindal</name></author><category term="2PC" /><category term="Malicious" /><category term="Oblivious Transfer" /><category term="Malicious" /><category term="Elette Boyle" /><category term="Geoffroy Couteau" /><category term="Niv Gilboa" /><category term="Yuval Ishai" /><category term="Lisa Kohl" /><category term="Peter Scholl" /><category term="CCS" /><summary type="html">Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Peter Rindal, Peter Scholl ~ eprint/2019/706 ~ CCS’19 We consider the problem of securely generating useful instances of two-party correlations, such as many independent copies of a random oblivious transfer (OT) correlation, using a small amount of communication. This problem is motivated by the goal of secure computation with silent preprocessing, where a low-communication input-independent setup, followed by local (“silent”) computation, enables a lightweight “non-cryptographic” online phase once the inputs are known. Recent works of Boyle et al. (CCS 2018, Crypto 2019) achieve this goal with good concrete efficiency for useful kinds of two-party correlations, including OT correlations, under different variants of the Learning Parity with Noise (LPN) assumption, and using a small number of “base” oblivious transfers. The protocols of Boyle et al. have several limitations. First, they require a large number of communication rounds. Second, they are only secure against semi-honest parties. Finally, their concrete efficiency estimates are not backed by an actual implementation. In this work we address these limitations, making three main contributions: Eliminating interaction. Under the same assumption, we obtain the first concretely efficient 2-round protocols for generating useful correlations, including OT correlations, in the semi-honest security model. This implies the first efficient 2-round OT extension protocol of any kind and, more generally, protocols for non-interactive secure computation (NISC) that are concretely efficient and have the silent preprocessing feature. Malicious security. We provide security against malicious parties (in the random oracle model) without additional interaction and with only a modest concrete overhead; prior to our work, no similar protocols were known with any number of rounds. Implementation. Finally, we implemented, optimized, and benchmarked our 2-round OT extension protocol, demonstrating that it offers a more attractive alternative to the OT extension protocol of Ishai et al. (Crypto 2003) in many realistic settings.</summary></entry><entry><title type="html">DiSE: Distributed Symmetric-key Encryption</title><link href="http://localhost:4000/hyde/publications/2018/10/06/DiSE.html" rel="alternate" type="text/html" title="DiSE: Distributed Symmetric-key Encryption" /><published>2018-10-06T00:00:00-07:00</published><updated>2018-10-06T00:00:00-07:00</updated><id>http://localhost:4000/hyde/publications/2018/10/06/DiSE</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2018/10/06/DiSE.html">&lt;p&gt;Shashank Agrawal, Payman Mohassel, Pratyay Mukherjee &amp;amp; Peter Rindal ~ &lt;a href=&quot;https://eprint.iacr.org/2018/727&quot;&gt;eprint/2018/727&lt;/a&gt; ~ &lt;a href=&quot;https://acmccs.github.io/papers/&quot;&gt;CCS’18&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Threshold cryptography provides a mechanism for protecting secret keys by sharing them among multiple parties, who then jointly perform cryptographic operations. An attacker who corrupts upto a threshold number of parties cannot recover the secrets or violate security. Prior works in this space have mostly focused on definitions and constructions for public-key cryptography and digital signatures, and thus do not capture the security concerns and efficiency challenges of symmetric-key based applications which commonly use long-term (unprotected) master keys to protect data at rest, authenticate clients on enterprise networks, and secure data and payments on IoT devices.&lt;/p&gt;

&lt;p&gt;We put forth the first formal treatment for distributed symmetric-key encryption, proposing new notions of correctness, privacy and authenticity in presence of malicious attackers. We provide strong and intuitive game-based definitions that are easy to understand and yield efficient constructions.&lt;/p&gt;

&lt;p&gt;We propose a generic construction of threshold authenticated encryption based on any distributed pseudorandom function (DPRF). When instantiated with the two different DPRF constructions proposed by Naor, Pinkas and Reingold (Eurocrypt 1999) and our enhanced versions, we obtain several efficient constructions meeting different security definitions. We implement these variants and provide extensive performance comparisons. Our most efficient instantiation uses only symmetric-key primitives and achieves a throughput of upto 1 million encryptions/decryptions per seconds, or alternatively a sub-millisecond latency with upto 18 participating parties.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="MPC" /><category term="Threshold Cryptography" /><category term="Malicious" /><category term="Shashank Agrawal" /><category term="Payman Mohassel" /><category term="Pratyay Mukherjee" /><category term="CCS" /><summary type="html">Shashank Agrawal, Payman Mohassel, Pratyay Mukherjee &amp;amp; Peter Rindal ~ eprint/2018/727 ~ CCS’18 Threshold cryptography provides a mechanism for protecting secret keys by sharing them among multiple parties, who then jointly perform cryptographic operations. An attacker who corrupts upto a threshold number of parties cannot recover the secrets or violate security. Prior works in this space have mostly focused on definitions and constructions for public-key cryptography and digital signatures, and thus do not capture the security concerns and efficiency challenges of symmetric-key based applications which commonly use long-term (unprotected) master keys to protect data at rest, authenticate clients on enterprise networks, and secure data and payments on IoT devices. We put forth the first formal treatment for distributed symmetric-key encryption, proposing new notions of correctness, privacy and authenticity in presence of malicious attackers. We provide strong and intuitive game-based definitions that are easy to understand and yield efficient constructions. We propose a generic construction of threshold authenticated encryption based on any distributed pseudorandom function (DPRF). When instantiated with the two different DPRF constructions proposed by Naor, Pinkas and Reingold (Eurocrypt 1999) and our enhanced versions, we obtain several efficient constructions meeting different security definitions. We implement these variants and provide extensive performance comparisons. Our most efficient instantiation uses only symmetric-key primitives and achieves a throughput of upto 1 million encryptions/decryptions per seconds, or alternatively a sub-millisecond latency with upto 18 participating parties.</summary></entry><entry><title type="html">Label-PSI from Fully Homomorphic Encryption with Malicious Security</title><link href="http://localhost:4000/hyde/publications/2018/10/06/labeled-psi.html" rel="alternate" type="text/html" title="Label-PSI from Fully Homomorphic Encryption with Malicious Security" /><published>2018-10-06T00:00:00-07:00</published><updated>2018-10-06T00:00:00-07:00</updated><id>http://localhost:4000/hyde/publications/2018/10/06/labeled-psi</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2018/10/06/labeled-psi.html">&lt;p&gt;Hao Chen, Kim Laine &amp;amp; Peter Rindal ~ &lt;a href=&quot;https://eprint.iacr.org/2018/787&quot;&gt;eprint/2018/787&lt;/a&gt; ~ &lt;a href=&quot;https://acmccs.github.io/papers/&quot;&gt;CCS’18&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Private Set Intersection (PSI) allows two parties, the sender and the receiver, to compute the intersection of their private sets without revealing extra information to each other. We are interested in the &lt;em&gt;unbalanced&lt;/em&gt; PSI setting, where (1) the receiver’s set is significantly smaller than the sender’s, and (2) the receiver (with the smaller set) has a low-power device. Also, in a &lt;em&gt;Labeled PSI&lt;/em&gt; setting, the sender holds a label per each item in its set, and the receiver obtains the labels from the items in the intersection. We build upon the unbalanced PSI protocol of Chen, Laine, and Rindal (CCS 2017) in several ways: we add efficient support for arbitrary length items, we construct and implement an unbalanced Labeled PSI protocol with small communication complexity, and also strengthen the security model using Oblivious Pseudo-Random Function (OPRF) in a pre-processing phase. Our protocols outperform previous ones: for an intersection of 220 and 512 size sets of arbitrary length items our protocol has a total online running time of just 1 second (single thread), and a total communication cost of 4 MB. For a larger example, an intersection of 228 and 1024 size sets of arbitrary length items has an online running time of 12 seconds (multi-threaded), with less than 18~MB of total communication.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="2PC" /><category term="FHE" /><category term="Private Set Intersection" /><category term="Semi-honest" /><category term="Malicious" /><category term="Hao Chen" /><category term="Kim Laine" /><category term="CCS" /><summary type="html">Hao Chen, Kim Laine &amp;amp; Peter Rindal ~ eprint/2018/787 ~ CCS’18 Private Set Intersection (PSI) allows two parties, the sender and the receiver, to compute the intersection of their private sets without revealing extra information to each other. We are interested in the unbalanced PSI setting, where (1) the receiver’s set is significantly smaller than the sender’s, and (2) the receiver (with the smaller set) has a low-power device. Also, in a Labeled PSI setting, the sender holds a label per each item in its set, and the receiver obtains the labels from the items in the intersection. We build upon the unbalanced PSI protocol of Chen, Laine, and Rindal (CCS 2017) in several ways: we add efficient support for arbitrary length items, we construct and implement an unbalanced Labeled PSI protocol with small communication complexity, and also strengthen the security model using Oblivious Pseudo-Random Function (OPRF) in a pre-processing phase. Our protocols outperform previous ones: for an intersection of 220 and 512 size sets of arbitrary length items our protocol has a total online running time of just 1 second (single thread), and a total communication cost of 4 MB. For a larger example, an intersection of 228 and 1024 size sets of arbitrary length items has an online running time of 12 seconds (multi-threaded), with less than 18~MB of total communication.</summary></entry><entry><title type="html">ABY3: A Mixed Protocol Framework for Machine Learning</title><link href="http://localhost:4000/hyde/publications/2018/04/30/aby3.html" rel="alternate" type="text/html" title="ABY3: A Mixed Protocol Framework for Machine Learning" /><published>2018-04-30T00:00:00-07:00</published><updated>2018-04-30T00:00:00-07:00</updated><id>http://localhost:4000/hyde/publications/2018/04/30/aby3</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2018/04/30/aby3.html">&lt;p&gt;Payman Mohassel &amp;amp; Peter Rindal ~ &lt;a href=&quot;https://eprint.iacr.org/2018/403&quot;&gt;eprint/2018/403&lt;/a&gt; ~ &lt;a href=&quot;https://acmccs.github.io/papers/&quot;&gt;CCS’18&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Machine learning is widely used to produce models for a range of applications and is increasingly offered as a service by major technology companies. However, the required massive data collection raises privacy concerns during both training and prediction stages.&lt;/p&gt;

&lt;p&gt;In this paper, we design and implement a general framework for privacy-preserving machine learning and use it to obtain new solutions for training linear regression, logistic regression and neural network models. Our protocols are in a three-server model wherein data owners secret share their data among three servers who train and evaluate models on the joint data using three-party computation (3PC).
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Our main contribution is a new and complete framework (ABY3) for efficiently switching back and forth between arithmetic, binary, and Yao 3PC which is of independent interest. Many of the conversions are based on new techniques that are designed and optimized for the first time in this paper. We also propose new techniques for fixed-point multiplication of shared decimal values that extends beyond the three-party case, and customized protocols for evaluating piecewise polynomial functions. We design variants of each building block that is secure against &lt;em&gt;malicious adversaries&lt;/em&gt; who deviate arbitrarily.&lt;/p&gt;

&lt;p&gt;We implement our system in C++. Our protocols are up to &lt;em&gt;four orders of magnitude&lt;/em&gt; faster than the best prior work, hence significantly reducing the gap between privacy-preserving and plaintext training.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="MPC" /><category term="Honest Majority" /><category term="semi-honest" /><category term="Secret Sharing" /><category term="Garbled Circuit" /><category term="Malicious" /><category term="Machine Learning" /><category term="Payman Mohassel" /><category term="CCS" /><summary type="html">Payman Mohassel &amp;amp; Peter Rindal ~ eprint/2018/403 ~ CCS’18 Machine learning is widely used to produce models for a range of applications and is increasingly offered as a service by major technology companies. However, the required massive data collection raises privacy concerns during both training and prediction stages. In this paper, we design and implement a general framework for privacy-preserving machine learning and use it to obtain new solutions for training linear regression, logistic regression and neural network models. Our protocols are in a three-server model wherein data owners secret share their data among three servers who train and evaluate models on the joint data using three-party computation (3PC).</summary></entry><entry><title type="html">Malicious-Secure Private Set Intersection via Dual Execution</title><link href="http://localhost:4000/hyde/publications/2017/10/09/duelEx-psi.html" rel="alternate" type="text/html" title="Malicious-Secure Private Set Intersection via Dual Execution" /><published>2017-10-09T00:00:00-07:00</published><updated>2017-10-09T00:00:00-07:00</updated><id>http://localhost:4000/hyde/publications/2017/10/09/duelEx-psi</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2017/10/09/duelEx-psi.html">&lt;p&gt;Peter Rindal &amp;amp; Mike Rosulek ~ &lt;a href=&quot;https://eprint.iacr.org/2017/769&quot;&gt;eprint/2017/769&lt;/a&gt; ~ &lt;a href=&quot;https://acmccs.github.io/papers/&quot;&gt;CCS’17&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Private set intersection (PSI) allows two parties, who each hold a set of items, to compute the intersection of those sets without revealing anything about other items. Recent advances in PSI have significantly improved its performance for the case of semi-honest security, making semi-honest PSI a practical alternative to insecure methods for computing intersections. However, the semi-honest security model is not always a good fit for real-world problems.&lt;/p&gt;

&lt;p&gt;In this work, we introduce a new PSI protocol that is secure in the presence of malicious adversaries. Our protocol is based entirely on fast symmetric-key primitives and inherits important techniques from state-of-the-art protocols in the semi-honest setting. Our novel technique to strengthen the protocol for malicious adversaries is inspired by the dual execution technique of Mohassel &amp;amp; Franklin (PKC 2006). Our protocol is optimized for the random-oracle model, but can also be realized (with a performance penalty) in the standard model.&lt;/p&gt;

&lt;p&gt;We demonstrate our protocol’s practicality with a prototype implementation. To securely compute the intersection of two sets of size 220
requires only 13 seconds with our protocol, which is ∼12× faster than the previous best malicious-secure protocol (Rindal &amp;amp; Rosulek, Eurocrypt 2017), and only 3× slower than the best semi-honest protocol (Kolesnikov et al., CCS 2016).&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="2PC" /><category term="Malicious" /><category term="Oblivious Transfer" /><category term="Private Set Intersection" /><category term="Mike Rosulek" /><category term="ccs" /><summary type="html">Peter Rindal &amp;amp; Mike Rosulek ~ eprint/2017/769 ~ CCS’17 Private set intersection (PSI) allows two parties, who each hold a set of items, to compute the intersection of those sets without revealing anything about other items. Recent advances in PSI have significantly improved its performance for the case of semi-honest security, making semi-honest PSI a practical alternative to insecure methods for computing intersections. However, the semi-honest security model is not always a good fit for real-world problems. In this work, we introduce a new PSI protocol that is secure in the presence of malicious adversaries. Our protocol is based entirely on fast symmetric-key primitives and inherits important techniques from state-of-the-art protocols in the semi-honest setting. Our novel technique to strengthen the protocol for malicious adversaries is inspired by the dual execution technique of Mohassel &amp;amp; Franklin (PKC 2006). Our protocol is optimized for the random-oracle model, but can also be realized (with a performance penalty) in the standard model. We demonstrate our protocol’s practicality with a prototype implementation. To securely compute the intersection of two sets of size 220 requires only 13 seconds with our protocol, which is ∼12× faster than the previous best malicious-secure protocol (Rindal &amp;amp; Rosulek, Eurocrypt 2017), and only 3× slower than the best semi-honest protocol (Kolesnikov et al., CCS 2016).</summary></entry><entry><title type="html">PIR-PSI: Scaling Private Contact Discovery</title><link href="http://localhost:4000/hyde/publications/2017/10/09/pir-psi.html" rel="alternate" type="text/html" title="PIR-PSI: Scaling Private Contact Discovery" /><published>2017-10-09T00:00:00-07:00</published><updated>2017-10-09T00:00:00-07:00</updated><id>http://localhost:4000/hyde/publications/2017/10/09/pir-psi</id><content type="html" xml:base="http://localhost:4000/hyde/publications/2017/10/09/pir-psi.html">&lt;p&gt;Daniel Demmler, Peter Rindal, Mike Rosulek &amp;amp; Ni Trieu ~ &lt;a href=&quot;https://eprint.iacr.org/2018/579&quot;&gt;eprint/2018/579&lt;/a&gt; ~ &lt;a href=&quot;https://doi.org/10.1515/popets-2018-0037&quot;&gt;PETS’18&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;An important initialization step in many social-networking applications is contact discovery, which allows a user of the service to identify which of its existing social contacts also use the service. Naive approaches to contact discovery reveal a user’s entire set of social/professional contacts to the service, presenting a significant tension between functionality and privacy.&lt;/p&gt;

&lt;p&gt;In this work, we present a system for private contact discovery, in which the client learns only the intersection of its own contact list and a server’s user database, and the server learns only the (approximate) size of the client’s list. The protocol is specifically tailored to the case of a small client set and large user database. Our protocol has provable security guarantees and combines new ideas with state-of-the-art techniques from private information retrieval and private set intersection.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;We report on a highly optimized prototype implementation of our system, which is practical on real-world set sizes. For example, contact discovery between a client with 1024 contacts and a server with 67 million user entries takes 1.36 sec (when using server multi-threading) and uses only 4.28 MiB of communication.&lt;/p&gt;</content><author><name>Peter Rindal</name></author><category term="2PC" /><category term="Semi-honest" /><category term="Private Set Intersection" /><category term="Mike Rosulek" /><category term="Ni Trieu" /><category term="Daniel Demmler" /><category term="PETS" /><summary type="html">Daniel Demmler, Peter Rindal, Mike Rosulek &amp;amp; Ni Trieu ~ eprint/2018/579 ~ PETS’18 An important initialization step in many social-networking applications is contact discovery, which allows a user of the service to identify which of its existing social contacts also use the service. Naive approaches to contact discovery reveal a user’s entire set of social/professional contacts to the service, presenting a significant tension between functionality and privacy. In this work, we present a system for private contact discovery, in which the client learns only the intersection of its own contact list and a server’s user database, and the server learns only the (approximate) size of the client’s list. The protocol is specifically tailored to the case of a small client set and large user database. Our protocol has provable security guarantees and combines new ideas with state-of-the-art techniques from private information retrieval and private set intersection.</summary></entry></feed>