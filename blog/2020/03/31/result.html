<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      result< T, E >: Seamless error_code's with C++ Coroutines &middot; Peter Rindal
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/hyde/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/hyde/favicon.png" />
<link rel="shortcut icon" href="/hyde/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/hyde/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="post">

    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/hyde/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Peter Rindal
      </a>
    </div>
    <p class="lead"></p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/hyde/">Home</a>
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
      <a class="page-link "
          href="/hyde/about.html">About</a>
    
  

  
    
  

  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  


  


  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/hyde/category/Blog.html">Blog</a>
    
  

  
    
      <a class="category-link "
          href="/hyde/category/Libraries.html">Libraries</a>
    
  

  
    
      <a class="category-link "
          href="/hyde/category/Publications.html">Publications</a>
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/hyde/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/hyde/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/hyde/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <p>
  &copy; 2020.
  <a href="/hyde/LICENSE.md">MIT License.</a>
</p>

</div>

    <main class="container">
      <header>
  <h1 class="post-title">result< T, E >: Seamless error_code's with C++ Coroutines</h1>
</header>
<div class="content">
  <div class="post-meta">
  <span class="post-date">31 Mar 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hyde/category/Blog.html">
          Blog
        </a>
      
    
  </span>
</div>


  <div class="post-body">
    <h3 id="the-idea">The Idea</h3>

<p>The other day I was reviewing some code when I saw the use of a macro to simplify handling an <code class="highlighter-rouge">error_code</code> like type. I’m sure most of us have seen code like this</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Either return the error or assign </span>
<span class="c1">// the value type of rexpr to lhs.</span>
<span class="cp">#define ASSIGN_OR_RETURN(lhs, rexpr) ...
</span>
<span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ASSIGN_OR_RETURN</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bar</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this example <code class="highlighter-rouge">result&lt;T,E&gt;</code> is a discriminated union / sum type, it will either hold the expected type <code class="highlighter-rouge">T</code>, or in can of an error it will hold an <code class="highlighter-rouge">E</code>. The macro <code class="highlighter-rouge">ASSIGN_OR_RETURN</code> returns the error type if the error type is active and otherwise assigns the value type to <code class="highlighter-rouge">i</code>.</p>

<p>I think its pretty obvious why the use of the macro is less than desirable.
 <!--more-->
Apprently the author of the code had picked this pattern up at google where <code class="highlighter-rouge">result&lt;T, error_code&gt; = StatusOr&lt;T&gt;</code>.  While chatting they mentioned how they wish C++ had the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">Rust</a> <code class="highlighter-rouge">operator ?</code> which effectively does the same thing as the macro.</p>

<p>But this got me thinking… Shortly before I was playing around with the new C++ coroutine TS (very excited ;). From my understanding, the coroutine keyword <code class="highlighter-rouge">co_await</code> effectively allows us to shim in arbitrary code at the site of the  <code class="highlighter-rouge">co_await</code> operator. In particular, this mechanism can allow us to return early from the function. I was invisioning something like the following:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">foo</span><span class="p">();</span>
  <span class="n">co_return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>While I am not the first to have this basic observation, e.g. <a href="https://github.com/facebook/folly/blob/72c71129647d3f12402364e818336125d911fa8d/folly/Expected.h">folly::expected</a>, <a href="https://www.reddit.com/r/cpp/comments/a68wjo/investigating_what_is_really_needed_to_have/">this reddit post</a>, I beleive this capability deserves more attention and is a good example to learn from. Moreover, while exploring this idea I quickly discovered that this code be further simplified to just</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
  <span class="n">co_return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>All three of these example have the same exact behavior. If <code class="highlighter-rouge">foo()</code> returns an <code class="highlighter-rouge">error_code</code> then <code class="highlighter-rouge">bar()</code> will propegate this same <code class="highlighter-rouge">error_code</code> threw the return channel.</p>

<p>To my suprise this solution can also provides guarantted exception safety. Consider the following,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>
  <span class="n">co_return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>At first glance the <code class="highlighter-rouge">noexcept</code> seems incorrect. However, it is possible to configure the <code class="highlighter-rouge">result&lt;T,E&gt;</code> type so that it can capture all exceptions and record them as the error type, in the case <code class="highlighter-rouge">error_core</code>. In the implementation I also show how to use <code class="highlighter-rouge">std::exception_ptr</code> as the error type to allow us to keep the runtime information contained in the current exception.</p>

<h3 id="the-resultte-type">The result&lt;T,E&gt; type</h3>

<p>The code I will be discussing can be found <a href="https://github.com/ladnir/result">here</a> but be warned it is just a prototype. For production level code that does some of that I have described see <a href="https://github.com/facebook/folly/blob/72c71129647d3f12402364e818336125d911fa8d/folly/Expected.h">folly::expected</a>. My <code class="highlighter-rouge">result&lt;T,E&gt;</code> has the follwoing form</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">E</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ExceptionHandler</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">result</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">error_type</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">exception_handler</span> <span class="o">=</span> <span class="n">ExceptionHandler</span><span class="p">;</span>

    <span class="c1">// constructors...</span>
    <span class="n">result</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span>
    <span class="n">result</span><span class="p">(</span><span class="k">const</span> <span class="n">error_type</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
    <span class="n">result</span><span class="p">(</span><span class="k">const</span> <span class="n">result</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">...</span>

    <span class="c1">// accessing members </span>
    <span class="kt">bool</span> <span class="n">has_value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">has_error</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">();</span>
    <span class="n">error_type</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">();</span>
    <span class="p">...</span>
    
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Promise</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">awaiter</span> <span class="p">{</span>
      <span class="p">...</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="n">promise_type</span> <span class="p">{</span>
      <span class="p">...</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For now we can ignore the <code class="highlighter-rouge">exception_handler</code>. The critical type for our concerns is the <code class="highlighter-rouge">promise_type</code> type. When the compiler sees the one of the <code class="highlighter-rouge">co_*</code> keywords in a function body the compiler will look up the <code class="highlighter-rouge">promise_type</code> of the current return type, in our case <code class="highlighter-rouge">result&lt;T,E&gt;::promise_type</code>. The compiler will then roughtly transform the function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">bar</span><span class="p">();</span>
  <span class="n">co_return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>into</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">return_type</span> <span class="o">=</span> <span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">return_type</span><span class="o">::</span><span class="n">promise_type</span><span class="p">;</span>
  <span class="n">promise_type</span> <span class="n">prom</span><span class="p">;</span>
  <span class="n">return_type</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">prom</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
  
  <span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
  <span class="n">return_type</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">promise_type</span><span class="o">::</span><span class="n">await_transform</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">await_ready</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">a</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">prom</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span>

  <span class="n">ret</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>As the implementer of <code class="highlighter-rouge">result&lt;T,E&gt;</code>, we have control over the body of these inserted functions. It is then a relatively simple matter to acheive the desired logic. First, we will have <code class="highlighter-rouge">promise_type::get_return_object() -&gt; promise_type&amp;</code> return a reference to itself and give <code class="highlighter-rouge">result&lt;T,E&gt;</code> the following constructor</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">result</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">class</span> <span class="nc">promise_type</span> <span class="p">{</span>
        <span class="n">result</span><span class="o">*</span> <span class="n">result_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">};</span>    

    <span class="n">result</span><span class="p">(</span><span class="n">proise_type</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">promise</span><span class="p">.</span><span class="n">result_ptr</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">promise_type</code> will then hold the pointer to the <code class="highlighter-rouge">result</code> as a member. The <code class="highlighter-rouge">awaiter</code> type <code class="highlighter-rouge">a</code> will then similarly hold a pointer <code class="highlighter-rouge">b_ptr</code> to <code class="highlighter-rouge">b</code> which is provided via the <code class="highlighter-rouge">await_transform(b)</code> function. During the call to <code class="highlighter-rouge">a.await_ready()</code>, the implementation will check if <code class="highlighter-rouge">b</code> contains an <code class="highlighter-rouge">error_type</code> and if so return <code class="highlighter-rouge">false</code>. The subsequant call to <code class="highlighter-rouge">a.await_suspend(prom)</code> can then set <code class="highlighter-rouge">*prom.result_ptr = a.b_ptr-&gt;error()</code>. Alternative, if <code class="highlighter-rouge">b</code> does not contain an error then <code class="highlighter-rouge">a.await_resume()</code> can similarly return the underlying <code class="highlighter-rouge">value_type</code> from <code class="highlighter-rouge">b</code>.</p>

<p>While this gives us a solid solution, we still must use the <code class="highlighter-rouge">co_await</code> keywork to generate this transformation. If you recall eariler, we desired to write</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="n">result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
  <span class="n">co_return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For this we will add an implicit converstion operator <code class="highlighter-rouge">result&lt;T,E&gt;::operator T()</code> which throws an <code class="highlighter-rouge">E</code> in the event that the error type is active. This convertion operator will then implicicitly be called for <code class="highlighter-rouge">int i = bar();</code>. In the event that an <code class="highlighter-rouge">E</code> is throw we can imidiately catch it using the following</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">template</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">result</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">class</span> <span class="nc">promise_type</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">unhandled_exception</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">try</span><span class="p">{</span> <span class="k">throw</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">catch</span><span class="p">(</span><span class="n">error_type</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">result_ptr</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">};</span>  

    <span class="n">result</span><span class="p">(</span><span class="n">proise_type</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">promise</span><span class="p">.</span><span class="n">result_ptr</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<p>The way this all works is as follows. When an exception is thrown in a coroutine it is automaticly caught and within the <code class="highlighter-rouge">catch</code> block the function<code class="highlighter-rouge">promise_type::unhandled_exception()</code> is called. The current exception can then be rethrow using <code class="highlighter-rouge">throw;</code> which in turn allows us to catch the underlying <code class="highlighter-rouge">error_type</code> and store it in the return <code class="highlighter-rouge">result&lt;T,E&gt;</code>.</p>

<p>The final missing piece is how to handle arbitrary exceptions. For this the library provides a way for the user to customize how an exception is converted into an error type. This is achieved by providing the third template parameter <code class="highlighter-rouge">exception_handler</code> with two member functions that contain the desired logic. When working with error codes one option is to simply throw out all the runtime information associated with the exception and store a generic error code indicating that an exception was caught and supressed. This option can be found <a href="https://github.com/ladnir/result/blob/master/result/result.h#L341">here</a>.</p>

<p>Alternatively, it is possible to instantiate an <code class="highlighter-rouge">result</code> type with <code class="highlighter-rouge">result&lt;T, std::exception_ptr&gt;</code> where no runtime exception information is thrown away. It is then possible to specify an <code class="highlighter-rouge">exception_handler</code> which catches all exceptions and stores them as an <code class="highlighter-rouge">std::exception_ptr</code>, if the user does an unchecked access to the <code class="highlighter-rouge">value_type</code>, the captured <code class="highlighter-rouge">std::exception_ptr</code> can be rethrown using <code class="highlighter-rouge">std::rethrow_exception(...)</code>. This option can be found <a href="https://github.com/ladnir/result/blob/master/result/result.h#L360">here</a>.</p>

<p>As a final remark I’d like to say that this is just an example of what could be done. It is far from clear that everything I stated here is actually the best design choice. Certainly the ideas about how to remove the the use of the <code class="highlighter-rouge">co_await</code> keyword by throwing an exception is likely not the most efficient, although it is hard to say what the compiler will optimize away.</p>

<p>Cheers,
Peter</p>

    



<div class="post-tags">
  
    
    <a href="/hyde/tags.html#cpp">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">cpp</span>
    </a>
  
    
    <a href="/hyde/tags.html#coroutine">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">coroutine</span>
    </a>
  
</div>
  </div>

  
  <!-- <section class="comments">
    <h2>Comments</h2>
    
  <div id="disqus_thread">
    <button class="disqus-load" onClick="loadDisqusComments()">
      Load Comments
    </button>
  </div>
  <script>

  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW
  *  TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT:s
  *  https://disqus.com/admin/universalcode/#configuration-variables
  */
  var disqus_config = function () {
    this.page.url = "http://localhost:4000/hyde/blog/2020/03/31/result.html";
    this.page.identifier = "" ||
                           "http://localhost:4000/hyde/blog/2020/03/31/result.html";
  }
  function loadDisqusComments() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//peter_rindal_shortname.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  }
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a>.
  </noscript>



  </section> -->

  <section class="related">
  <h2>Related Posts</h2>
  <ul class="posts-list">
    
      <li>
        <h3>
          <a href="/hyde/publications/2019/04/27/db-join.html">
            Fast Database Joins for Secret Shared Data
            <small>27 Apr 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/hyde/publications/2019/02/27/silent-ot.html">
            Efficient Two-Round OT Extension and Silent Non-Interactive Secure Computation
            <small>27 Feb 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/hyde/publications/2019/02/27/endemic-ot.html">
            Endemic Oblivious Transfer
            <small>27 Feb 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</section>

</div>

    </main>

    <!-- Optional footer content -->

  </body>
</html>
